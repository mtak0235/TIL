템플릿이란 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경이 되는 성질을 가지는 부분으로부터 독립시켜
효과적으로 활용될 수 있도록 하는 방법

# 1. 다시 보는 초난감 DAO

UserDao는 아직 예외 상황에 대한 처리가 되어있지 않다.

## 1.1 예외 처리 기능을 갖춘 DAO

정상적인 JDBC코드의 흐름을 따르지 않았을 때, DB conntection 이라는 제한적인 리소스를 반드시 반환해야한다.

### JDBC 수정 기능의 예외 처리 코드

```java
    public void deleteAll() throws SQLException {
        Connection c = dataSource.getConnection();
        PreparedStatement ps = c.prepareStatement("delete from users");
        ps.executeUpdate();
        ps.close();
        c.close();
    }
```

공유 자원 : connection, preparedStatement

여기서 예외가 발생하면 메소드의 실행을 끝마치지 못하고 바로 메소드를 빠져나간다. 즉, close()가 실행되지 않아 리소스가 반환되지 않을 수 있다.

> 보통 connection, preparedStatement는 pool 형식으로 운영된다.
> pool 안에 제한된 수의 resource를 만들어두고 필요할 때 이를 할당하고 반환하면 다시 풀에 넣는 방식이다.
> 요청이 많은 서버 환경에 유리하다.

😎어떤 예외에도 리소스를 반환하게 만들어주자.

/try/catch/finally

```java
    public void deleteAll() throws SQLException {
        Connection c = null;
        PreparedStatement ps = null;
        try {
            c = dataSource.getConnection();
            ps = c.prepareStatement("delete from users");
            ps.executeUpdate();
        } catch (SQLException e) {
            throw e;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (SQLException e) {
                }
            }
            if (c != null) {
                try {
                    c.close();
                } catch (SQLException e) {
                }
            }
        }
    }
```

close()도 try/catch를 해야할까 의문이 들 수 있지만 해야 한다. 안했다가 위의 close()에서 SQLException 나면 다음 if문이 실행되지 않기 때문이다.
따라서 마지막 close()는 사실 try/catch가 불필요할 수 있지만 예외 처리 하고싶어질 수 있으니까 넣었다.

### JDBC 조회 기능의 예외 처리

공유 자원 :  Connection, preparedStatement, ResultSet

​

```java
    public int getCount() throws SQLException {

        Connection c = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            c = dataSource.getConnection();
            ps = c.prepareStatement("select count(*) from users");
            rs = ps.executeQuery();
            rs.next();
            return rs.getInt(1);
        } catch (SQLException e) {
            throw e;
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException ignored) {
                }
            }
            if (ps != null) {
                try {
                    ps.close();
                } catch (SQLException e) {

                }
            }
            if (c != null) {
                try {
                    c.close();
                } catch (SQLException e) {
                    
                }
            }

        }
    }
```

와 코드 반복 보소

## 2. 변하는 것과 변하지 않는 것

## 2.1 JDBC try/catch/finally 코드의 문제점

변하지 않지만 중복되서 나타나는 코드와 로직에 따라 자꾸 변하는 코드를 잘 분리해야 한다.

## 2.2 분리와 재사용을 위한 디자인 패턴 적용

변하는 부분과 변하지 않는 부분으로 분리해보자

```java
public void deleteAll() throws SQLException {
        Connection c = null;
        PreparedStatement ps = null;
        try {
            c = dataSource.getConnection();
            ps = c.prepareStatement("delete from users"); //유일하게 변함
            ps.executeUpdate();
        } catch (SQLException e) {
            throw e;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (SQLException e) {
                }
            }
            if (c != null) {
                try {
                    c.close();
                } catch (SQLException e) {
                }
            }
        }
    }
```

### 메소드 추출

```java
    public void deleteAll() throws SQLException {
        Connection c = null;
        PreparedStatement ps = null;
        try {
            c = dataSource.getConnection();
            ps = makeStatement(c);
            ps.executeUpdate();
        } catch (SQLException e) {
            throw e;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (SQLException e) {
                }
            }
            if (c != null) {
                try {
                    c.close();
                } catch (SQLException e) {
                }
            }
        }
    }

    private PreparedStatement makeStatement(Connection c) throws SQLException {
        return c.prepareStatement("delete from users");
    }
```

🤔다른 메소드에도 쓸 것을 추출해야 하는데 반대로 했다;;

### 템플릿 메소드 패턴의 적용

템플릿 메소드 패턴으로 분리해 보자. 이 친구는 상속을 통해 기능을 확장해서 사용할 수 있다. 변하지 않는 부분은 슈퍼 클래스에 두고, 변하는 부분은 추상 메소드로 정의해둬서 서브
클래스에서 오버라이드 하여 새롭게 정의해 쓰도록 한다.

```java
package com.example.tobby.user.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class UserDaoDeleteAll extends UserDao {

    @Override
    protected PreparedStatement makeStatement(Connection c) throws SQLException {
            return c.prepareStatement("delete from users");
    }
}

```

🤔어.. 그럼 JDBC method가 4개면 UserDao의 서브 클래스를 4개 만들어야 되네? 이미 컴파일 시점에서 그 관계가 정해져 버리니까 유연성이 떨어진다.

### 전략 패턴의 적용

클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 패턴.
![image](https://github.com/mtak0235/TIL/assets/48946398/9f86d36a-4459-4318-a0f8-ac21877c4902)

변하지 않는 부분 == contextMethod()

deleteAll()에서 변하지 않는 부분

* DB connection 가져오기
* **PreparedStatement를 만들어줄 외부 기능** 호출하기
* 전달받은 PreparedStatement 실행하기
* 예외가 발생하면 이를 다시 메소드 밖을 던지기
* 모든 경우에 만들어진 PreparedStatement, connection 닫아주기

"PreparedStatement를 만들어줄 외부 기능"  이 전략 패턴에서 말한 strategy!
자, 이제 전략을 인터페이스로 뺴고 구현체까지 만들어보자.

```java
package com.example.tobby.user.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public interface StatementStrategy {
    PreparedStatement makePreparedStatement(Connection connection) throws SQLException;
}

```

```java
package com.example.tobby.user.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class DeleteAllStatement implements StatementStrategy {
    @Override
    public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
        PreparedStatement ps = connection.prepareStatement("delete from users");
        return ps;
    }
}

```

```java
public void deleteAll() throws SQLException {
        Connection c = null;
        PreparedStatement ps = null;
        try {
            c = dataSource.getConnection();
            DeleteAllStatement strategy = new DeleteAllStatement();
            ps = strategy.makePreparedStatement(c);
            ps.executeUpdate();
        } catch (SQLException e) {
            throw e;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (SQLException e) {
                }
            }
            if (c != null) {
                try {
                    c.close();
                } catch (SQLException e) {
                }
            }
        }
    }
```

🤔특정 구현체를 알고 있네?

### DI적용을 위한 client/context 분리

전략 패턴 가라사대, Context가 어떤 전략을 사용하게 할 것인지는 Context를 사용하는 앞단의 Client가 결정한다. Context는 Client로부터 전달 받은 그
Strategy구현 클래스의 obj를 사용할 뿐이다.

😎틀에 박힌 작업을 하는 코드들이 담긴 context method를 만들어보자.

```java
    public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException{
        Connection c = null;
        PreparedStatement ps = null;
        try {
            c = dataSource.getConnection();
            ps = stmt.makePreparedStatement(c);
            ps.executeUpdate();
        } catch (SQLException e) {
            throw e;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (SQLException e) {
                }
            }
            if (c != null) {
                try {
                    c.close();
                } catch (SQLException e) {
                }
            }
        }
    } //c
```

😎자, 이번에는 전략 오브젝트를 만들고 컨텍스트를 호출하는 client method인 deleteAll()을 작성해보자.

```java
    public void deleteAll() throws SQLException {
        StatementStrategy st = new DeleteAllStatement();
        jdbcContextWithStatementStrategy(st);
    }
```

> DI에 필요한 배우는 총 4명
>
> * 의존 관계에 있는 obj(strategy) 두개
> * 이 관계를 다이나믹하게 설정해주는 obj factory
> * 이를 이용하는 client

# 3. JDBC 전략 패턴의 최적화

> 현 상황
>
> * UserDao의 deleteAll() :  client
> * jdbcContextWithStatementStrategy() : context
> * PreParedStatement : strategy interface

## 3.1 전략 클래스의 추가 정보

add()에도 적용해보자!

```java
package com.example.tobby.user.dao;

import com.example.tobby.user.domain.User;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class AddStatement implements StatementStrategy {
    User user;

    public AddStatement(User user) {
        this.user = user;
    }

    @Override
    public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
        PreparedStatement ps = connection.prepareStatement(
                "insert into users (id, name, password) values (?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());
        return ps;
    }
}

```

```java
    public void add(User user) throws ClassNotFoundException, SQLException
    {
        StatementStrategy statement = new AddStatement(user);
        jdbcContextWithStatementStrategy(statement);
    }
```

## 3.2 전략과 client의 동거

🤔Dao 메소드 마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다...이러면 로직마다 상속을 하는 템플릿 메소드 패턴과 다를게 뭔가? 또 Dao
method에서 StatementStrategy에 전달할 User같은 부가 정보가 있는 경우 이를 담아둘 obj와 이걸 전달 받을 생성자도 만들어야 한다. 즉, 이 obj가 쓰이는
시점은 전략 obj를 호출할 때 이므로 잠시라도 어딘가 저장해 둘 수 밖에 없다..

### 로컬 클래스

😎클래스 파일이 많아져? StatementStrategy 전략 클래스를 UserDao내부 클래스로 정의해버려! 어차피 DeleteAllStatement나 AddStatement는
UserDao밖에 안쓰잖아?

```java
    public void add(User user) throws ClassNotFoundException, SQLException {
        class AddStatement implements StatementStrategy {
            User user;

            public AddStatement(User user) {
                this.user = user;
            }

            @Override
            public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
                PreparedStatement ps = connection.prepareStatement(
                        "insert into users (id, name, password) values (?,?,?)");
                ps.setString(1, user.getId());
                ps.setString(2, user.getName());
                ps.setString(3, user.getPassword());
                return ps;
            }
        }
        
        StatementStrategy statement = new AddStatement(user);
        jdbcContextWithStatementStrategy(statement);
    }
```

🤔오호 AddStatement를 local class로 만들었군요? 그렇다면

> 중첩 클래스
>
> * 다른 클래스 내부에 정의된 클래스
> * 종류
    >
* static class
  >
* 독립적으로 obj로 만들어질 수 있다.
>   * inner class
      >
* 자신이 정의된 클래스의 obj안에서만 만들어질 수 있다.
>     * 자신이 정의된 메소드 의 로컬 변수 중 final이 붙은 놈들에 직접 접근할 수 있다.
>     * 범위에 따른 종류
        >
* member inner class
  >
* member 필드 처럼 obj 레벨에 정의됨
>       * local class
          >
* method 레벨에 정의됨
>       * anonymous inner class
          >
* 이름이 없음.

```java
    public void add(User user) throws ClassNotFoundException, SQLException {
        class AddStatement implements StatementStrategy {
            @Override
            public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
                PreparedStatement ps = connection.prepareStatement(
                        "insert into users (id, name, password) values (?,?,?)");
                ps.setString(1, user.getId());
                ps.setString(2, user.getName());
                ps.setString(3, user.getPassword());
                return ps;
            }
        }

        StatementStrategy statement = new AddStatement();
        jdbcContextWithStatementStrategy(statement);
    }
```

### 익명 내부 클래스

* 클래스의 선언과 obj생성이 결합된 형태로 만들어진다.
* 상속할 클래스 or 구현할 interface를 다음과 같은 형태로 만들어 쓴다.
    * `new 인터페이스이름 (){ 클래스 본문}`

😎AddStatement를 익명 내부 클래스로 만들어보자

```java
    public void add(User user) throws ClassNotFoundException, SQLException {

        StatementStrategy statement = new StatementStrategy() {
            @Override
            public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
                PreparedStatement ps = connection.prepareStatement(
                        "insert into users (id, name, password) values (?,?,?)");
                ps.setString(1, user.getId());
                ps.setString(2, user.getName());
                ps.setString(3, user.getPassword());
                return ps;
            }
        };
        jdbcContextWithStatementStrategy(statement);
    }
```

🤔차피 statement한번밖에 안쓸거 노룩패스 가자

```java
    public void add(User user) throws ClassNotFoundException, SQLException {
        jdbcContextWithStatementStrategy(new StatementStrategy() {

            @Override
            public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
                PreparedStatement ps = connection.prepareStatement(
                        "insert into users (id, name, password) values (?,?,?)");
                ps.setString(1, user.getId());
                ps.setString(2, user.getName());
                ps.setString(3, user.getPassword());
                return ps;
            }
        });
    }
```

😎deleteAllStatement()도 바꿔보자

```java
    public void deleteAll() throws SQLException {
        jdbcContextWithStatementStrategy(new StatementStrategy() {
            @Override
            public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
                PreparedStatement ps = connection.prepareStatement("delete from users");
                return ps;
            }
        });
    }
```

# 4. 컨텍스트와 DI

## 4.1 JdbcContext의 분리

전략 구조로 보면,,

* UserDao : client
* 익명 내부 클래스 : strategy 구현체
* jdbcContextWithstatementStrategy : context 특. 다른 Dao에서도 사용 가능

😎jdbcContextWithStatementStrategy()를 UserDao밖으로 독립시키자.

### 클래스 분리

```java
package com.example.tobby.user.dao;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class JdbcContext {
    
    private final DataSource dataSource;

    public JdbcContext(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException {
        Connection c = null;
        PreparedStatement ps = null;
        try {
            c = dataSource.getConnection();
            ps = stmt.makePreparedStatement(c);
            ps.executeUpdate();
        } catch (SQLException e) {
            throw e;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (SQLException e) {
                }
            }
            if (c != null) {
                try {
                    c.close();
                } catch (SQLException e) {
                }
            }
        }
    }
}
```

```java
public class UserDao {
    private JdbcContext jdbcContext ;
    public void setJdbcContext(JdbcContext jdbcContext) {
        this.jdbcContext = jdbcContext;
    }
    ...
}
```

### 빈 의존관계 변경

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="connectionMaker" class="com.example.tobby.user.dao.DConnectionMaker"/>
    <bean id="jdbcContext" class="com.example.tobby.user.dao.JdbcContext">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <bean id="userDao" class="com.example.tobby.user.dao.UserDao">
        <property name="dataSource" ref="dataSource"/>
        <property name="jdbcContext" ref="jdbcContext"/>
    </bean>
    <bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
        <property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost/tobby"/>
        <property name="username" value="tobaby"/>
        <property name="password" value="0000"/>
    </bean>
</beans>
```

## 4.2 JdbcContext의 특별할 DI

UserDao는 이전처럼 interface를 하나 끼지도 않고 구체 클래스인 JdbcContext를 의존했다. 비록 런타임 시에 DI방식으로 외부에서 오브젝트를 주입해주긴
하지만..

### 스프링 빈으로 DI

DI가 넓게 보면 객체의 생성과 관계 설정에 대한 권한을 외부에 주는 것인데,, 아무리 그렇다 해도 UserDao가 구체적인 클래스 JdbcContext를 주입받아야 하는 이유가
뭘까?

1. JdbcContext가 여러 client에게 Jdbc context 메소드를 제공하는 서비스 obj이기에 스프링 컨테이너의 싱글톤 registry가 관리해야한다.
2. JdbcContext가 DI를 통해 다른 빈에 의존하기 때문이다.

인터페이스가 없다는 건 매우 강하게 결합되어 있다는 의미다. UserDao가 JDBC방식이 아닌 JPA나 ORM을 사용해야 한다면 JdbcContext도 통째로 바뀌어야 한다.

### 코드를 이용하는 수동 DI

JdbcContext를 스프링 빈으로 등록하지 않고 그 역할을 UserDao에 위임하는거다!

대신 위에서 말한 이점을 챙겨가려면 Dao마다 JdbcContext를 만들어야 하고, JdbcContext가 의존하는 DataSource obj는 UserDao가 주입해 줘야
겠지만..

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
<!--    <bean id="connectionMaker" class="com.example.tobby.user.dao.DConnectionMaker"/>-->
<!--    <bean id="jdbcContext" class="com.example.tobby.user.dao.JdbcContext">-->
<!--        <property name="dataSource" ref="dataSource"/>-->
<!--    </bean>-->
    <bean id="userDao" class="com.example.tobby.user.dao.UserDao">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
        <property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost/tobby"/>
        <property name="username" value="tobaby"/>
        <property name="password" value="0000"/>
    </bean>
</beans>
```

```java
public class UserDao {

    private JdbcContext jdbcContext ;
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.jdbcContext = new JdbcContext();
        this.jdbcContext.setDataSource(dataSource);
        
        this.dataSource = dataSource;
    }
}
```

# 5. 템플릿과 롤백

지금까지 전략 패턴의 기본 구조에 익명 내부 클래스를 활용했다. 이런 방식을 **template/callback 패턴**이라고 한다.

* template : 전략 패턴의 context
* callback : 익명 내부 클래스로 만들어지는 obj

> 템플릿 메소드 패턴
> 고정된 틀을 가진 템플릿 메소드를 슈퍼 클래스로 두고, 바뀌는 부분을 서브 클래스의 메소드에 두는 구조
>
> 콜백(callback)
> 실행되는 것을 목적으로 다름 obj의 메소드에 전달되는 obj.
> 자바에서는 메소드 자체를 parameter로 전달할 방법이 없어서 메소드가 담긴 obj를 전달해야 한다. 이런 obj를 functional obj라고 한다.

## 5.1 템플릿/콜백의 동작 원리

### 템플릿/콜백의 특징

여러 개의 메소드를 가진 일반적인 인터페이스를 사용할 수 있는 전략 패턴과 달리 단일 메소드 인터페이스를 사용하는 탬플릿/콜백 패턴의 콜백은 템플릿의 작업 흐름 중 특정 기능을
위해 한번만 호출된다. 물론 템플릿에서 여러 전략을 사용한다면 여러개의 콜백을 넘겨주면 된다. => 메소드 레벨에서 DI

> 콜백은 일반적으로 하나의 메소드를 가진 인터페이스를 구현한 익명 내부 클래스로 만들어진다.
> 요 메소드는 보통 작업 흐름 중에 만들어지는 context정보를 전달 받을 용도의 파라미터가 있다.

### JdbcContext에 적용된 템플릿/콜백

![image](https://github.com/mtak0235/TIL/assets/48946398/206769d7-baf7-475d-854e-957d6d810cc5)

조회 작업에는 보통 템플릿의 작업 결과를 client에게 리턴해준다.

## 5.2 편리한 콜백의 재활용

복잡한 익명 내부 클래스의 사용을 최소화 해보자!

```java
    public void deleteAll() throws SQLException {
        jdbcContext.workWithStatementStrategy(new StatementStrategy() {
            @Override
            public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
                PreparedStatement ps = connection.prepareStatement("delete from users");
                return ps;
            }
        });
    }
```

🤔바인딩할 parameter 없이 만들어진 SQL을 이용해 PreParedStatement를 만들기만 하면 되는 콜백이 많을 것 같다. 즉, 저기서 바뀔 가능성이 있는 것은 "
delete from users"라는 문자열 뿐이다.

```java
    public void deleteAll() throws SQLException {
        executeSql("delete from users");
    }

    private void executeSql(final String query) throws SQLException {
        jdbcContext.workWithStatementStrategy(new StatementStrategy() {
            @Override
            public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
                PreparedStatement ps = connection.prepareStatement(query);
                return ps;
            }
        });
    }
```

### 콜백과 템플릿의 결합

executeSql()을 UserDao만 쓰기엔 아깝다. 이렇게 재사용 가능한 콜백을

```java
    public void deleteAll() throws SQLException {
        this.jdbcContext.executeSql("delete from users");
    }
```

```java
package com.example.tobby.user.dao;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class JdbcContext {


    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
    public JdbcContext(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public JdbcContext() {
    }

    public void executeSql(final String query) throws SQLException {
        workWithStatementStrategy(new StatementStrategy() {
            @Override
            public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
                PreparedStatement ps = connection.prepareStatement(query);
                return ps;
            }
        });
    }
    public void workWithStatementStrategy(StatementStrategy stmt) throws SQLException {
        Connection c = null;
        PreparedStatement ps = null;
        try {
            c = dataSource.getConnection();
            ps = stmt.makePreparedStatement(c);
            ps.executeUpdate();
        } catch (SQLException e) {
            throw e;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (SQLException e) {
                }
            }
            if (c != null) {
                try {
                    c.close();
                } catch (SQLException e) {
                }
            }
        }
    }
}
```

## 5.3 템플릿/콜백의 응용

### 테스트와 try/catch/finally

간단한 템플릿 콜백 예제를 만들어보자.

파일 하나 열어서 모든 라인의 숫자를 더한 합을 돌려주는 코드를 만들어보겠다.

```java
package com.example.tobby;

import com.example.tobby.templateCallback.Calculator;
import org.junit.jupiter.api.Test;

import java.io.IOException;

import static org.assertj.core.api.Assertions.assertThat;

public class CalcSumTest {
    @Test
    public void sumOfNumbers() throws IOException {
        Calculator calculator = new Calculator();
        Integer sum = calculator.calcSum("C:\\Users\\192293\\TIL\\spring\\tobby\\tobby\\src\\test\\java\\com\\example\\tobby\\numbers.txt");
        assertThat(sum).isEqualTo(10);

    }
}

```

```java
package com.example.tobby.templateCallback;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Calculator {
    public Integer calcSum(String filepath) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(filepath));
        Integer sum = 0;
        String line = null;
        while ((line = br.readLine()) != null) {
            sum += Integer.valueOf(line);
        }
        br.close();
        return sum;
    }
}

```

파일을 처리하다가 예외 상황이 발생하면 로그를 남기는 기능도 추가하자

```java
package com.example.tobby.templateCallback;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Calculator {
    public Integer calcSum(String filepath) throws IOException {
        BufferedReader br = null;
        try {
            br = new BufferedReader(new FileReader(filepath));
            Integer sum = 0;
            String line = null;
            while ((line = br.readLine()) != null) {
                sum += Integer.valueOf(line);
            }
            br.close();
            return sum;
        } catch (IOException e) {
            System.out.println("e.getMessage() = " + e.getMessage());
            throw e;
        } finally {
            if (br != null) {
                try {
                    br.close();
                } catch (IOException e) {
                    System.out.println("e.getMessage() = " + e.getMessage());
                }
            }
        }
    }
}

```

### 중복의 제거와 template/callback 설계

모든 숫자의 곱을 계산하는 기능을 추가해야 한다는 요구가 생겼다.

🤔템플릿/콜백 패턴을 적용하려면 ..

1. 템플릿에 담을 반복되는 작업 흐름이 무엇인가?
2. 템플릿이 콜백에 전해줄 정보는 무엇이고, 콜백이 템플릿에 돌려줄 내용은 무엇인가?
3. 템플릿이 작업을 마친 후, client에게 전달할 내용은 무엇인가?

```java
package com.example.tobby.templateCallback;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Calculator {
    public Integer calcSum(String filepath) throws IOException {
        BufferedReaderCallback sumCallback = new BufferedReaderCallback() {

            @Override
            public Integer doSomethingWithReader(BufferedReader br) throws IOException {
                Integer sum = 0;
                String line = null;
                while ((line = br.readLine()) != null) {
                    sum += Integer.valueOf(line);
                }
                return sum;
            }
        };
        return fileReadTemplate(filepath, sumCallback);
    }

    public Integer calcMultiply(String filepath) throws IOException {
        BufferedReaderCallback multiplyCallback = new BufferedReaderCallback() {
            @Override
            public Integer doSomethingWithReader(BufferedReader br) throws IOException {
                Integer multiply = 1;
                String line = null;
                while ((line = br.readLine()) != null) {
                    multiply *= Integer.valueOf(line);
                }
                return multiply;
            }
        };
        return fileReadTemplate(filepath, multiplyCallback);
    }
    public Integer fileReadTemplate(String filepath, BufferedReaderCallback callback) throws IOException {
        BufferedReader br = null;
        try {
            br = new BufferedReader(new FileReader(filepath));
            int ret = callback.doSomethingWithReader(br);
            return ret;
        } catch (IOException e) {
            System.out.println("e.getMessage() = " + e.getMessage());
            throw e;
        } finally {
            if (br != null) {
                try {
                    br.close();
                } catch (IOException e) {
                    System.out.println("e.getMessage() = " + e.getMessage());
                }
            }
        }
    }
}

```

```java
package com.example.tobby.templateCallback;

import java.io.BufferedReader;
import java.io.IOException;

public interface BufferedReaderCallback {
    Integer doSomethingWithReader(BufferedReader br) throws IOException;
}

```

```java
package com.example.tobby.templateCallback;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.*;

class CalculatorTest {

    Calculator calculator;
    String numFilePath;
    @BeforeEach
    public void setUp() {
        this.calculator = new Calculator();
        this.numFilePath = "C:\\Users\\192293\\TIL\\spring\\tobby\\tobby\\src\\test\\java\\com\\example\\tobby\\numbers.txt";
    }
    @Test
    void calcSum() throws IOException {
        assertThat(calculator.calcSum(this.numFilePath)).isEqualTo(10);
    }

    @Test
    void calcMultiply() throws IOException {
        assertThat(calculator.calcMultiply(this.numFilePath)).isEqualTo(24);
    }
}
```

### 템플릿/콜백의 재설계

calcMultiply()와 calcSum()이 연산 부분 빼고 모두 동일한 코드다. 찾았다 콜백!

```java
package com.example.tobby.templateCallback;

public interface LineCallback {
    Integer doSomethingWithLine(String line, Integer value);
}

```

```java
package com.example.tobby.templateCallback;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Calculator {
    public Integer calcSum(String filepath) throws IOException {
        LineCallback sumCallback = new LineCallback() {

            @Override
            public Integer doSomethingWithLine(String line, Integer value) {
                return value + Integer.valueOf(line);
            }
        };
        return lineReadTemplate(filepath, sumCallback, 0);
    }

    public Integer calcMultiply(String filepath) throws IOException {
        LineCallback sumCallback = new LineCallback() {

            @Override
            public Integer doSomethingWithLine(String line, Integer value) {
                return value * Integer.valueOf(line);
            }
        };
        return lineReadTemplate(filepath, sumCallback, 1);
    }
    public Integer fileReadTemplate(String filepath, BufferedReaderCallback callback) throws IOException {
        BufferedReader br = null;
        try {
            br = new BufferedReader(new FileReader(filepath));
            int ret = callback.doSomethingWithReader(br);
            return ret;
        } catch (IOException e) {
            System.out.println("e.getMessage() = " + e.getMessage());
            throw e;
        } finally {
            if (br != null) {
                try {
                    br.close();
                } catch (IOException e) {
                    System.out.println("e.getMessage() = " + e.getMessage());
                }
            }
        }
    }

    public Integer lineReadTemplate(String filepath, LineCallback callback, int initValue) {
        BufferedReader br = null;
        try {
            br = new BufferedReader(new FileReader(filepath));
            Integer ret = initValue;
            String line = null;
            while ((line = br.readLine()) != null) {
                ret = callback.doSomethingWithLine(line, ret);
            }
            return ret;
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {

        }
    }
}

```

### 제네릭스를 이용한 콜백 인터페이스

파일의 각 라인을 연결한 하나의 스트링을 돌려주는 기능을 만들어보자!
근데 콜백이고, 템플릿이고 죄다 Integer를 반환하네? 타입 파라미터 개념을 도입한 Generics를 사용해보자.

```java
package com.example.tobby.templateCallback;

public interface LineCallback<T> {
    T doSomethingWithLine(String line, T value);
}

```

```java
package com.example.tobby.templateCallback;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Calculator {
    public Integer calcSum(String filepath) throws IOException {
        LineCallback<Integer> sumCallback = new LineCallback<Integer>() {

            @Override
            public Integer doSomethingWithLine(String line, Integer value) {
                return value + Integer.valueOf(line);
            }
        };
        return lineReadTemplate(filepath, sumCallback, 0);
    }

    public Integer calcMultiply(String filepath) throws IOException {
        LineCallback<Integer> sumCallback = new LineCallback<Integer>() {

            @Override
            public Integer doSomethingWithLine(String line, Integer value) {
                return value * Integer.valueOf(line);
            }
        };
        return lineReadTemplate(filepath, sumCallback, 1);
    }

    public String concatenate(String filepath) {
        LineCallback<String> concatenateCallback = new LineCallback<String>() {
            @Override
            public String doSomethingWithLine(String line, String value) {
                return value + line;
            }
        };
        return lineReadTemplate(filepath, concatenateCallback, "");
    }
    public Integer fileReadTemplate(String filepath, BufferedReaderCallback callback) throws IOException {
        BufferedReader br = null;
        try {
            br = new BufferedReader(new FileReader(filepath));
            int ret = callback.doSomethingWithReader(br);
            return ret;
        } catch (IOException e) {
            System.out.println("e.getMessage() = " + e.getMessage());
            throw e;
        } finally {
            if (br != null) {
                try {
                    br.close();
                } catch (IOException e) {
                    System.out.println("e.getMessage() = " + e.getMessage());
                }
            }
        }
    }

    public <T> T lineReadTemplate(String filepath, LineCallback<T> callback, T initValue) {
        BufferedReader br = null;
        try {
            br = new BufferedReader(new FileReader(filepath));
            T ret = initValue;
            String line = null;
            while ((line = br.readLine()) != null) {
                ret = callback.doSomethingWithLine(line, ret);
            }
            return ret;
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {

        }
    }
}

```

```java
package com.example.tobby.templateCallback;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.*;

class CalculatorTest {

    Calculator calculator;
    String numFilePath;
    @BeforeEach
    public void setUp() {
        this.calculator = new Calculator();
        this.numFilePath = "C:\\Users\\192293\\TIL\\spring\\tobby\\tobby\\src\\test\\java\\com\\example\\tobby\\numbers.txt";
    }
    @Test
    void calcSum() throws IOException {
        assertThat(this.calculator.calcSum(this.numFilePath)).isEqualTo(10);
    }

    @Test
    void calcMultiply() throws IOException {
        assertThat(this.calculator.calcMultiply(this.numFilePath)).isEqualTo(24);
    }

    @Test
    public void concatenate() {
        assertThat(this.calculator.concatenate(this.numFilePath)).isEqualTo("1234");
    }
}
```

😎관전 포인트

* 리턴 값을 갖는 템플릿
* 템플릿 안에서 여러번 호출되는 콜백
* generics타입을 갖는 메소드, 콜백 인터페이스

# 6. spring의 JdbcTemplate

스프링은 JDBC를 이용하는 DAO에게 줄 다양한 콜백과 템플릿이 있다.  
스프링이 제공하는 JDBC 코드용 기본 템플릿은 JdbcTemplate이다.

😎자, 이제 JdbcContext를 버리고 JdbcTemplate을 사용할 시간이다.

```java
public class UserDao {

    private JdbcContext jdbcContext ;
    private DataSource dataSource;

    private JdbcTemplate jdbcTemplate;
    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);

        this.dataSource = dataSource;
    }
}
```

## 6.1 update()

😎deleteAll()에 먼저 적용해보자. 지금까지 만든 콜백은 StatementStrategy 인터페이스의 makePreparedStatement() 다.

JdbcTemplate의 콜백은 PreparedStatementCreator 인터페이스의 createPreparedStatement()다.

템플릿으로부터 connection 을 받아 PreparedStatement를 만들어 돌려주는 구조는 같다. 지금까지 템플릿 메소드는
workWithStatementStrategy()
JdbcTemplate의 템플릿 메소드는 update()

```java
    public void deleteAll() throws SQLException {
//        this.jdbcContext.executeSql("delete from users");
        this.jdbcTemplate.update(new PreparedStatementCreator() {
            @Override
            public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                return con.prepareStatement("delete from users");
            }
        });
    }
    
```

🤔아..executeSql은 SQL만 줘도 미리 준비된 콜백을 만들어 템플릿을 호출하는 것까지 한 큐인데..저 update()는 콜백도 줘야 하네?

😎오버라이드된 update()중 sql만 넘겨도 그렇게 동작하는게 있지.

```java
    public void deleteAll() throws SQLException {
        this.jdbcTemplate.update("delete from users");
    }
```

😎뿐만 아니라 add()의 콜백이 수행하는 두가지 작업 (PreparedStatement만들기, 파라미터 바인딩)
을 훨씬 간단하게 바꿀 수 있어.

```java
    public void add(User user) throws ClassNotFoundException, SQLException {
//        jdbcContext.workWithStatementStrategy(new StatementStrategy() {
//
//            @Override
//            public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
//                PreparedStatement ps = connection.prepareStatement(
//                        "insert into users (id, name, password) values (?,?,?)");
//                ps.setString(1, user.getId());
//                ps.setString(2, user.getName());
//                ps.setString(3, user.getPassword());
//                return ps;
//            }
//        });
        this.jdbcTemplate.update("insert into users (id, name, password) values(?,?,?)", user.getId(), user.getName(), user.getPassword());
    }
```

## 6.2 queryForInt()

getCount()에서 변하는 부분만 콜백으로 만들어보자.

```java
    public int getCount() throws SQLException {
        return this.jdbcTemplate.query(new PreparedStatementCreator() {
            @Override
            public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                return con.prepareStatement("select count(*) from users");
            }
        }, new ResultSetExtractor<Integer>() {
            @Override
            public Integer extractData(ResultSet rs) throws SQLException, DataAccessException {
                rs.next();
                return rs.getInt(1);
            }
        });
}
```

템플릿 메소드

* query()

콜백

* PreparedStatementCreator : 템플릿으로부터 connection 을 받아 PreparedStatement를 만들어 돌려주는 콜백
* ResultSetExtractor :  템플릿이 PreparedStatement 쿼리를 실행해서 얻은 ResultSet을 전달 받아 원하는 값을 추출해서 템플릿에 전달하는 콜백
    * 제네릭스 타입의 파라미터를 가지고 있어 제너릭 타입의 메소드에도 적용되어 query()템플릿의 리턴 타입도 함께 바뀐다.

🤔콜백이 여러개네? sql의 실행 결과가 하나인 코드는 흔할 것 같아서 템플릿 안으로 옮겨도 될 것 같아. 이런 기능을 내장한 queryForObject()라는 템플릿이 있다.

```java
    public int getCount() throws SQLException {
        return this.jdbcTemplate.queryForObject("select count(*) from users", Integer.class);
    }
```

## 6.3 queryForObject()

get()에 JdbcTemplate을 적용해보자.

* sql 바인딩이 필요한 치환자가 있다.
* ResultSet에서 복잡한 User obj를 만들어야 한다.

😎ResultSetExtractor 콜백 대신에 RowMapper콜백을 사용하자. 둘 다 ResultSet을 전달 받아 필요한 정보를 추출해서 리턴하는 방식이다.
ResultSetExtractor는 ResultSet을 한번 전달 받아 알아서 추출 작업을 모두 진행하고 최종 결과를 바로 리턴하는데, RowMapper는 ResultSet의 로우
하나를 매핑하기 위해 사용되기 때문에 로우가 여러개이면 여러번 호출될 수 있다.

queryForObject()는 쿼리 실행 결과가 한 로우라고 기대한다. 따라서 이미 rs.next()로 첫번째 로우로 이동해 있는다. 고로 ResultSet에서 rs.next()
할 필요 없다.

``` java
    public User get(String id) throws ClassNotFoundException, SQLException {
//        Connection c = dataSource.getConnection();
//
//        PreparedStatement ps = c.prepareStatement(
//                "select * from users where id = ?"
//        );
//        ps.setString(1, id);
//
//        User user = null;
//        ResultSet rs = ps.executeQuery();
//        if (rs.next()) {
//            user = new User();
//            user.setId(rs.getString("id"));
//            user.setName(rs.getString("name"));
//            user.setPassword(rs.getString("password"));
//        }
//        rs.close();
//        ps.close();
//        c.close();
//        if (user == null) throw new EmptyResultDataAccessException(1);
//        return user;
        return this.jdbcTemplate.queryForObject("select * from users where id=?", new Object[]{id},new RowMapper<User>() {
            @Override
            public User mapRow(ResultSet rs, int rowNum) throws SQLException {
                User user = new User();
                user.setId(rs.getString("id"));
                user.setName(rs.getString("name"));
                user.setPassword(rs.getString("password"));
                return user;
            }
        });
```

## 6.4 query()

### 기능 정의와 테스트 작성

getAll()만들어 보자.

```java
    @Test
    public void getAll() throws SQLException, ClassNotFoundException {
        dao.deleteAll();
        dao.add(user1);//yeji
        List<User> users1 = dao.getAll();
        assertThat(users1.size()).isEqualTo(1);
        checkSameUser(user1, users1.get(0));
        dao.add(user2);//doyun
        List<User> users2 = dao.getAll();
        assertThat(users2.size()).isEqualTo(2);
        checkSameUser(user2, users2.get(0));
        checkSameUser(user1, users2.get(1));
        dao.add(user3);//mtak
        List<User> users3 = dao.getAll();
        assertThat(users3.size()).isEqualTo(3);
        checkSameUser(user2, users3.get(0));
        checkSameUser(user1, users3.get(1));
        checkSameUser(user3, users3.get(2));
    }
```

### query() 템플릿을 이용하는 getAll()구현

queryForObject()는 로우 하나를 기대하는 반면 query()는 여러 개의 로우가 나오는 경우에 쓸 수 있다.

```java
 public List<User> getAll() {
        return this.jdbcTemplate.query("select * from users order by id", new RowMapper<User>() {
            @Override
            public User mapRow(ResultSet rs, int rowNum) throws SQLException {
                User user = new User();
                user.setId(rs.getString("id"));
                user.setName(rs.getString("name"));
                user.setPassword(rs.getString("password"));
                return user;
            }
        });
    }
```

### 테스트 보완

getAll() negative test도 추가해보자

```java
    @Test
    public void getAll() throws SQLException, ClassNotFoundException {
        dao.deleteAll();
        dao.add(user1);//yeji
        List<User> users1 = dao.getAll();
        assertThat(users1.size()).isEqualTo(1);
        checkSameUser(user1, users1.get(0));
        dao.add(user2);//doyun
        List<User> users2 = dao.getAll();
        assertThat(users2.size()).isEqualTo(2);
        checkSameUser(user2, users2.get(0));
        checkSameUser(user1, users2.get(1));
        dao.add(user3);//mtak
        List<User> users3 = dao.getAll();
        assertThat(users3.size()).isEqualTo(3);
        checkSameUser(user2, users3.get(0));
        checkSameUser(user1, users3.get(1));
        checkSameUser(user3, users3.get(2));
        List<User> users0 = dao.getAll();
        assertThat(users0.size()).isEqualTo(0);
    }
```

## 6.5 재사용 가능한 콜백의 분리

### DI를 위한 코드 정리

DataSource instance를 제거하자. 그리고 jdbcTemplate을 직접 스프링 반으로 등록하고 싶으니까 setDataSource는 setJdbcTemplate으로
바꾸자.

```java
public class UserDao {
    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }
}
```

### 중복 제거

RowMapper의 내용이 같네? 기능 확장에 따라 중복이 더 심해질 것 같으니까 재사용하자. 그리고 RowMapper콜백은 하나 만들어서 공유하자.

```java
package com.example.tobby.user.dao;

import com.example.tobby.user.domain.User;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;

import javax.sql.DataSource;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;


public class UserDao {
    private JdbcTemplate jdbcTemplate;
    private final RowMapper<User> userMapper = new RowMapper<>() {
        @Override
        public User mapRow(ResultSet rs, int rowNum) throws SQLException {
            User user = new User();
            user.setId(rs.getString("id"));
            user.setName(rs.getString("name"));
            user.setPassword(rs.getString("password"));
            return user;
        }
    };;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void add(User user) throws ClassNotFoundException, SQLException {
//        jdbcContext.workWithStatementStrategy(new StatementStrategy() {
//
//            @Override
//            public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
//                PreparedStatement ps = connection.prepareStatement(
//                        "insert into users (id, name, password) values (?,?,?)");
//                ps.setString(1, user.getId());
//                ps.setString(2, user.getName());
//                ps.setString(3, user.getPassword());
//                return ps;
//            }
//        });
        this.jdbcTemplate.update("insert into users (id, name, password) values(?,?,?)", user.getId(), user.getName(), user.getPassword());
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
//        Connection c = dataSource.getConnection();
//
//        PreparedStatement ps = c.prepareStatement(
//                "select * from users where id = ?"
//        );
//        ps.setString(1, id);
//
//        User user = null;
//        ResultSet rs = ps.executeQuery();
//        if (rs.next()) {
//            user = new User();
//            user.setId(rs.getString("id"));
//            user.setName(rs.getString("name"));
//            user.setPassword(rs.getString("password"));
//        }
//        rs.close();
//        ps.close();
//        c.close();
//        if (user == null) throw new EmptyResultDataAccessException(1);
//        return user;
        return this.jdbcTemplate.queryForObject("select * from users where id=?", new Object[]{id}, userMapper);
    }

    public void deleteAll() throws SQLException {
        this.jdbcTemplate.update("delete from users");
    }


//    abstract protected PreparedStatement makeStatement(Connection c) throws SQLException;

    public int getCount() throws SQLException {
        return this.jdbcTemplate.queryForObject("select count(*) from users", Integer.class);
    }

    public List<User> getAll() {
       
        return this.jdbcTemplate.query("select * from users order by id", userMapper);
    }
}

```

### 템플릿/콜백 패턴과 UserDao

욕심이 난다.

1. userMapper가 앞으로 변경 안될 것 같으니까 UserDao의 DI용 property로 만들어버리면 어떨까? UserMapper를 빈으로 만들고 XML설정에
   User테이블의 필드 이름과 User obj property의 매핑 정보도 담을 수 있을 수도 있을 것이다.
2. Dao 메소드에서 사용하는 SQL문장을 UserDao코드가 아니라 외부 리소스에 담고 이를 읽어와 사용하게 하는건 어떨까? DB 테이블 이름이나 필드 이름을 변경하거나
   SQL쿼리를 최적화 해야 할 때도 UserDao코드에는 손을 댈 필요가 없다. 
