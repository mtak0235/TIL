스프링?
application framework

application framework?
application의 기본 틀 + 공통 프로그래밍 모델
➡ 스프링 컨테이너 + IoC/DI, 서비스 추상화, AOP + 기술 API

스프링 컨테이너
(=application context)
스프링 런타임 엔진
역할 : 설정 정보를 참고해서 app을 구성하는 OBJ를 생성&관리 한다.

 IoC/DI
Obj의 생명 주기와 의존 관계에 대한 프로그래밍 모델이다. 

서비스 추상화
구체적인 기술과 환경에 종속되지 않도록 유연한 추상 계층을 두는 방법

AOP
코드에 산재한 부가적인 기능을 독립적으로 모듈화 하는 프로그래밍 모델

기술 API
잘..모르겠음.

----

>  spring의 핵심은 객체지향적으로 app을 만드는데에 있다.

# 1. 초난감 DAO

* DAO
  * DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트

😎사용자 정보를  JDBC API 를 통해 DB에 저장하고  조회할 수 있는 DAO를 만들어 보자

> JavaBean
>
> * 디폴트생성자 + prpoperty를 가진 객체

* JDBC를 이용하는 작업의 순서
  1.  DB연결용 connection을 가져온다.
  2. SQL을 담은 statement를 만든다.
  3. 만든 statement를 실행한다.
  4. 조회의 경우, SQL쿼리의 실행 결과는 ResultSet으로 받아서 정보를 저장할 객체에 담아준다.
  5. 작업중에 생성된 Connection, Statement, ResultSet 같은 리소스를 닫아준다.
  6. JDBC API가 만든 Exception을 직접 처리하거나 메소드에 throws를 선언해 책임을 전가한다.

```java
package org.example.user.dao;

import org.example.user.domain.User;

import java.sql.*;

public class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobby", "tobaby", "0000");

        PreparedStatement ps = c.prepareStatement(
                "insert into users (id, name, password) values (?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());
        ps.executeUpdate();
        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobby", "tobaby", "0000");

        PreparedStatement ps = c.prepareStatement(
                "select * from users where id = ?"
        );
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
        rs.close();
        ps.close();
        c.close();
        return user;
    }
}

```

```java
package org.example.user.domain;

public class User {
    String id;
    String name;
    String password;

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getPassword() {
        return password;
    }

    public void setId(String id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

```

```java
package org.example.user;

import org.example.user.dao.UserDao;
import org.example.user.domain.User;

import java.sql.SQLException;

public class Main {
    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        UserDao dao = new UserDao();
        User user = new User();
        user.setId("mtak8");
        user.setName("탁민경");
        user.setPassword("1004");
        dao.add(user);
        System.out.println("succeed " + user.getId());

        User user1 = dao.get(user.getId());
        System.out.println(user1.getId());
        System.out.println(user1.getName());
        System.out.println(user1.getPassword());
        System.out.println("succeed" + user1.getId());
    }
}

```

# 2. DAO의 분리

## 2.1 관심사의 분리

변화가 한번에 한가지 관심에 집중적으로 일어나면, 우리는 그 한 가지 관심이 한 군데에 집중되게 해 줘야 한다.

## 2.2 커넥션 만들기의 추출

😎현재 DAO의 add()만 봐도 관심 사항이 3가지나 있다?

1. DB와 연결을 위한 커넥션.
   1. 어떤 드라이버를 사용할 것인지
   2. 어떤 로그인 정보를 쓰는지
   3. 커넥션을 생성하는 방법 뭐 쓰는지
2. SQL 담을 Statement 만들고 실행
   1. parameter로 넘어온 추가 정보를 statement에 바인딩 하는 것
   1. 어떤 SQL사용할지
3. 사용한 리소스들(statement, Connection) 해제

😎커넥션을 가져오는 중복된 코드를 분리해보자

```java
package org.example.user.dao;

import org.example.user.domain.User;

import java.sql.*;

public class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();

        PreparedStatement ps = c.prepareStatement(
                "insert into users (id, name, password) values (?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());
        ps.executeUpdate();
        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();

        PreparedStatement ps = c.prepareStatement(
                "select * from users where id = ?"
        );
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
        rs.close();
        ps.close();
        c.close();
        return user;
    }

    private static Connection getConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobby", "tobaby", "0000");
        return c;
    }
}

```

## 2.3  DB connection  만들기의 독립

😎 UserDao코드 숨겨서 판매하고 싶은데 getConnectio n 부분이 거래처마다 다르네,,
상속을 통해 확장해 볼까?

```java
package org.example.user.dao;

import org.example.user.domain.User;

import java.sql.*;

public abstract class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();

        PreparedStatement ps = c.prepareStatement(
                "insert into users (id, name, password) values (?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());
        ps.executeUpdate();
        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();

        PreparedStatement ps = c.prepareStatement(
                "select * from users where id = ?"
        );
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
        rs.close();
        ps.close();
        c.close();
        return user;
    }

    public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}

```

```java
package org.example.user.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DUserDao extends UserDao {
    @Override
    public Connection getConnection() throws ClassNotFoundException, SQLException {
            Class.forName("com.mysql.cj.jdbc.Driver");
            Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobby", "tobaby", "0000");
            return c;
    }
}
```

```java
package org.example.user.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class NUserDao extends UserDao {
    @Override
    public Connection getConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobby", "tobaby", "0000");
        return c;
    }
}

```

😁UserDao수정 없이 DB 연결 방법을 바꿀 수 있다!

> 이렇게 슈퍼 클래스에서 기본 로직 만들고, 그 일부를 추상화 시켜(추상 메소드나 protected 메소드 etc) 서브 클래스에서 이걸 필요에 맞게 구현해서 사용하도록 하는 방법을 **template method pattern**이라고 한다.
> 이렇게 서브 클래스에서 구체적인 obj 생성 방법을 결정하는 것을 **factory method pattern**이라고 한다.

# 3. DAO의 확장

🙄데이터 액세스 로직과 DB연결 로직. 이 두 관심사를 상하위 클래스로 분리시켰다. 
그치만 상속을 사용했네? 
서브 클래스가 슈퍼 클래스의 변화에 영향을 받아버린다...
뿐만 아니다 DAO마다 getConnection() 정의가 중복해서 나타날거다..

## 3.1 클래스의 분리

😎지금까지 저 두 관심사를 독립된 메소드로 찢어보고, 상하위 클래스로도 분리해 보았다. 이번에는 아예 독립적인 클래스로 찢어보자. 

```java
package org.example.user.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class SimpleConnectionMaker {
    public Connection makeNewConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobby", "tobaby", "0000");
        return c;
    }
}
```

```java
package org.example.user.dao;

import org.example.user.domain.User;

import java.sql.*;

public class UserDao {

    private SimpleConnectionMaker simpleConnectionMaker;

    public UserDao(SimpleConnectionMaker simpleConnectionMaker) {
        this.simpleConnectionMaker = simpleConnectionMaker;
    }

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = simpleConnectionMaker.makeNewConnection();

        PreparedStatement ps = c.prepareStatement(
                "insert into users (id, name, password) values (?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());
        ps.executeUpdate();
        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = simpleConnectionMaker.makeNewConnection();

        PreparedStatement ps = c.prepareStatement(
                "select * from users where id = ?"
        );
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
        rs.close();
        ps.close();
        c.close();
        return user;
    }
}

```

🙄이렇게 하니까 DUserDao, NUserDao이 제공하는 커넥션 기능을 쓰려면 또 UserDao를 수정해야 되네?

## 3.2 인터페이스 도입

```java
package org.example.user.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

interface ConnectionMaker {
    public Connection makeConnection() throws ClassNotFoundException, SQLException;
}

```

```java
package org.example.user.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DUserDao implements ConnectionMaker {

    @Override
    public Connection makeConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobby", "tobaby", "0000");
        return c;
    }
}

```

```java
package org.example.user.dao;

import org.example.user.domain.User;

import java.sql.*;

public class UserDao {

    private ConnectionMaker connectionMaker;

    public UserDao() {
        this.connectionMaker = new DUserDao();
    }

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();

        PreparedStatement ps = c.prepareStatement(
                "insert into users (id, name, password) values (?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());
        ps.executeUpdate();
        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();

        PreparedStatement ps = c.prepareStatement(
                "select * from users where id = ?"
        );
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
        rs.close();
        ps.close();
        c.close();
        return user;
    }
}

```

🙄UserDao에서 Connection 의 구현체를 알고 있네?

## 3.3 관계 설정 책임의 분리

🤔분리 되지 않은 관심사가 UserDao에 있다. UserDao-UserDao가 쓸 ConnectionMaker 의 특정 구현 클래스 사이의 관계를 설정해주는 것에 대한 관심!

UserDao를 사용하는 클라이언트에서 관계 설정을 해주면 어떨까?

> DUserDao -> DConnectionMaker
> NUserDao -> NConnectionMaker
> 이름 변경

```java
package org.example.user;

import org.example.user.dao.DConnectionMaker;
import org.example.user.dao.NUserDao;
import org.example.user.dao.UserDao;
import org.example.user.domain.User;

import java.sql.SQLException;

public class Main {
    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        UserDao dao = new UserDao(new DConnectionMaker());
        User user = new User();
        user.setId("mtak1");
        user.setName("탁민경");
        user.setPassword("1004");
        dao.add(user);
        System.out.println("succeed " + user.getId());

        User user1 = dao.get(user.getId());
        System.out.println(user1.getId());
        System.out.println(user1.getName());
        System.out.println(user1.getPassword());
        System.out.println("succeed" + user1.getId());
    }
}

```

## 3.4 원칙과 패턴

### 개방 폐쇄 원칙

* OCP (open closed principle)
* 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
* UserDao는 *DB 연결* 기능을 확장하는데는 열려있고, 자신의 핵심 코드는 그런 변화에 영향을 받지 않고 닫혀 있다. 

### 높은 응집도와 낮은 결합도

* 높은 응집도
  * 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다
  * 불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀있지 않다
* 낮은 결합도
  * 책임과 관심사가 다른 오브젝트 또는 모듈과는 느슨하게 연결된 형태를 유지한다.
  * 결합도
    * 하나의 오브젝트가 변경이 일어날 때, 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도

### 전략 패턴

* strategy pattern
  * 자신의 기능 맥락(context)에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘(strategy) 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
  * UserDao 가 context. ConnectionMaker가 변경 가능한 strategy.UserDaoTest는 context가 사용할 strategy를 제공.

# 4. 제어의 역전 (IoC)

## 4.1 오브젝트 팩토리

🤔UserDaoTest에 ConnectionMaker구현체와 UserDao의 관계를 맺어주는 일을 얼렁뚱땅 넘겼다..
이제 ConnectionMaker의 구현 클래스의 인스턴스와 UserDao 인트선스를 만드는 것과
그렇게 만들어진 두 오브젝트가 연결돼서 사용될 수 있게 관계를 맺어주는 기능들을 UserDaoTest로 부터 분리해 보자.

### 팩토리

객체의 생성 방법을 결정하고 그렇게 만들어진 obj를 돌려주는 오브젝트를 **factory**라고 부른다.

목적은 단 하나. 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 책임을 깔끔하게 분리하는 것이다. 

> 디자인 패턴의 추상 팩토리 패턴이나 팩토리 메소드 패턴과 다르다.

```java
package org.example.user.dao;

import org.example.user.domain.User;
import org.junit.jupiter.api.Test;

import java.sql.SQLException;

class UserDaoTest {

    @Test
    public void testConnection() throws SQLException, ClassNotFoundException {
        UserDao dao = new DaoFactory().userDao();
        User user = new User();
        user.setId("mtak1");
        user.setName("탁민경");
        user.setPassword("1004");
        dao.add(user);
        System.out.println("succeed " + user.getId());

        User user1 = dao.get(user.getId());
        System.out.println(user1.getId());
        System.out.println(user1.getName());
        System.out.println(user1.getPassword());
        System.out.println("succeed" + user1.getId());
    }
}
```

```java
package org.example.user.dao;

public class DaoFactory {
    public UserDao userDao() {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        UserDao userDao = new UserDao(connectionMaker);
        return userDao;
    }
}

```

### 설계도로서의 팩토리

* 실질적인 로직을 담당하는 컴포넌트
  * UserDao
    * 애플리케이션의 핵심적인 데이터 로직을 담당
  * ConnectionMaker
    * 기술 로직 담당
* 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의한 설설계도
  * DaoFactory
    * 오브젝트를 구성하고 관계를 정의

😊DaoFactory를 분리하니까 application component역할을 하는 obj와 application의 구조를 결정하는 구조를 결정하는 obj를 분리할 수 있게 됐어!

## 4.2 오브젝트 팩토리의 활용

🤔AccountDao, MessageDao가 추가되서 DaoFactory에 accountDao(), messageDao()를 추가해야 한다면?

```java
package org.example.user.dao;

public class DaoFactory {
    public UserDao userDao() {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        UserDao userDao = new UserDao(connectionMaker);
        return userDao;
    }
    public AccountDao accountDao() {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        AccountDao accountDao = new AccountDao(connectionMaker);
        return accountDao;
    }
    public MessageDao messageDao() {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        MessageDao messageDao = new MessageDao(connectionMaker);
        return messageDao;
    }
}

```

🙄어떤 ConnectionMaker 구현체를 쓸지 결정하는 코드가 중복해서 나타나네?

함수로 추출하자

```java
package org.example.user.dao;

public class DaoFactory {
    public UserDao userDao() {
        UserDao userDao = new UserDao(connectionMaker());
        return userDao;
    }
    public AccountDao accountDao() {
        AccountDao accountDao = new AccountDao(connectionMaker());
        return accountDao;
    }
    public MessageDao messageDao() {
        MessageDao messageDao = new MessageDao(connectionMaker());
        return messageDao;
    }

    public ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    }
}

```

## 4.3 제어권의 이전을 통한 제어 관계의 역전

🥺일반적으로 프로그램의 흐름은 client가 자신이 필요한 오브젝트를 결정하고 필요한 시점에서야 생성하며 만든 오브젝트의 메소드를 사용했다.

client가 제어했다.

😎제어의 역전이란 예시를 먼저 들어보자. 

1. 서블릿엔 main()이 없다. 서블릿을 지배하는 컨테이너가 적당한 때 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출한다. jsp, ejb도 컨테이너의 지배를 받는다. 

2. 템플릿 메소드 패턴에서 UserDao에서 추상 메소드 getConnection()를 만들어 놓으면 UserDao를 구현하는 서브 메소드야 일단 의무적으로 getConnetion()을 구현하긴 하지만 그게 언제 어떻게 사용될지는 모른다.  슈퍼 클래스인 UserDao의 템플릿 메소드인 add(), get()가  필요할 때 getConnection()을 사용한다. 

   서브 클래스는 (getConnection()의 )제어권을 상위 템플릿 메소드에 넘기고 자신은 필요할 때 호출당한다. 

3. 프레임워크는 라이브러리와 다르다. 프레임워크 위에 개발한 클래스를 등록해 두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 어플리케이션 코드를 사용하도록 만든다.

   어플리케이션 코드는 프레임워크가 짜 놓은 틀에서 수동적으로 동작해야 한다. 

 제어의 역전에는 프레임워크, 컨테이너 같이 애플리케이션 컴포넌트의 생성과 관계 설정, 사용, 생명주기 관리 들을 관장하는 존재가 필요하다. 

DaoFactory는 ob수준의 가장 간단한 IoC container, IoC framework라 불릴 수 있다. IoC 제어권을 가졌지 않은가?

# 5. 스프링의 IoC

스프링은 application 개발의 다양한 영역과 기술에 관여하지만,
스프링의 핵심은 application context(bean factory)다.
지금까지 만든 DaoFactory가 하는 일을 더 일반화 한 것이다 

## 5.1 오브젝트 팩토리를 이용한 스프링 IoC

### application context와 설정 정보

스프링에서, 

스프링(container)이 제어권을 가지고 직접 만들고 관계를 부여하는(제어의 역전이 적용된) 오브젝트를 bean이라 부른다. 

빈의 생성과 관계 설정 같은 제어를 담당하는 IoC object를 bean factory(=application context)라 부른다.
굳이 구분하자면,
bean factory는 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점을 둔 것이고,
application context는 application 전반에 걸쳐 모든 구성 요소의 제어 작업을 담당하는 IoC 엔진이라는 점에 초점을 둔 것이다. 
DaoFactory처럼 어떤 오브젝트를 생성하고 어디에 연결할지에 대한 정보를 직접 담고 있지는 않지만, 따로 **설정 정보를 담고 있는 무언가**를 가져와 이를 활용한다. (~~물론 DaoFactory는 설정정보까지 포함한 IoC엔진이다.~~)

### DaoFactory를 사용하는 application context

😎DaoFactory를 스프링의 빈 팩토리가 사용할 수 있는 본격적인 설정 정보로 만들어보자. 
@Configuration : "이건 bean factory를 위한 obj설정을 담당하는 클래스 입니다!"

@Bean: "이건 오브젝트를 만드는 메소드 입니다!"

```java
package com.example.tobby.user.dao;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class DaoFactory {
    @Bean
    public UserDao userDao() {
        UserDao userDao = new UserDao(connectionMaker());
        return userDao;
    }

    @Bean
    public ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    }
}

```



😎이제 DaoFactory를 설정 정보로 사용하는 application context를 만들어 보자! 

application context는 ApplicationConetext타입의 obj다.
구현체는 여러개인데 @Configuration이 붙은 자바 코드를 설정 정보로 사용하려면 AnnotationConfigContext를 이용하면 된다! 
만들 때 생성자 파라키터로 DaoFactory class넣어주는것 까먹지 말고!

준비된 ApplicationContext의 getBean()으로 UserDao obj를 가져올 수 있다. 

```java
package com.example.tobby;

import com.example.tobby.user.dao.DConnectionMaker;
import com.example.tobby.user.dao.DaoFactory;
import com.example.tobby.user.dao.UserDao;
import com.example.tobby.user.domain.User;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import java.sql.SQLException;

public class TobbyApplication {

    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(DaoFactory.class);
        UserDao dao = applicationContext.getBean("userDao", UserDao.class);
        User user = new User();
        user.setId("mtak3");
        user.setName("탁민경");
        user.setPassword("1004");
        dao.add(user);
        System.out.println("succeed " + user.getId());

        User user1 = dao.get(user.getId());
        System.out.println(user1.getId());
        System.out.println(user1.getName());
        System.out.println(user1.getPassword());
        System.out.println("succeed" + user1.getId());
    }

}

```

😊아까 @Bean을 붙였던 함수 `userDao`가 그대ㅐ로 빈의 이름이 됬다. 우린가 getBean()의 파라미터로 "userDao" , 즉 application context에 등록된 빈의 이름을 적은 이유이지.

🤷‍♂️애초에 userDao만드는 함수 이름은 cutieUserDao()로 지었어도, getBean()의 파라미터로 "cutieUserDao"로 빈을 찾을 수 있었는데!!

## 5.2 application context의 동작 방식

오브젝트 팩토리(DaoFactory)에 대응되는 것이 스프링의 application context다. 

application context의 다양한 이름

* ioc container
* spring container
* bean factory (엄밀히 하면 얘가 부모 인터페이스임)

🤔그렇다면 DaoFactory와 application context는 무슨 차이가 있나?

 DaoFactory는 Dao obj를 생성하고 DB생성 obj와 관계를 맺어준다.
ApplicationContext는 IoC를 적용할 모든 obj를 생성과 관계 설정을 담당한다. 
단, 직접 obj를 생성하고 관계를 맺어주는 코드가 있는건 아니고,  그런 생성 정보와 연관관계 정보를 별도의 설정 정보(Ex. @Configuration이 붙은 클래스)를 통해 얻는다. 

🤔

![image](https://github.com/mtak0235/TIL/assets/48946398/71910569-629d-4814-914e-71edcc054024)

1. 애플리케이션 컨텍스트는 DaoFactory 클래스를 설정정보로 등록해두고 @Bean이 붙은메소드의 이름을 가져와 빈 목록을 만들어둔다. 
2. 클라이언트가 애플리케이션 컨텍스트의  getBean() 메소드를 호출하면 자신의 빈 목록에서 요청한 이름이 있는지 찾고, 
   있다면  빈을 생성하는 메소드를 호출해서 오브젝트를 생성시킨 후 클라이언트에 돌려준다.

🤷‍♂️그래서 application context가 장점이 뭐길래 DaoFactory보다 낫다는 거야?

1.  클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.

application 이 발전하면 DaoFactory같은 IoC를 적용한 obj가 점점 많아질 것이고, 
➡클라이언트가 어느 팩토리 클래스를 써야 원하는 오브젝트를 가져올 수 있는지 알아야 한다.
➡그 때 마다 귀찮게 factory class를 생성해야 한다. 

그치만 ApplicationContext를 쓰면 obj factory가  아무리 많아져도 이를 클라이언트에서 알 필요가 없이 일관적인 방식으로 필요한 obj를 가져올 수 있다.

2. application context는 종합 IoC서비스를 제공해 준다.

application context는 단순리 obj 생성과 관계 설정만 할 뿐 아니라, ➡obj가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고
➡자동생성, obj에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등을 제공한다.
➡빈이 사용할 수 있는 기반 기술 서비스나 외부 시스템과의 연동 등을 컨테이너 차원에서 제공해준다. 

3. 빈을 검색하는 다양한 방법을 제공한다.

getBean()으로 빈의 이름을 통해 빈을 찾는데, 타입만으로 빈을 찾거나 특별한 annotation이 붙은 빈을 찾을수도 있다.

## 5.3 spring IoC 의 용어 정리

* bean
  * 스프링이 IoC로 관리하는 obj
  * 모든 obj가 다 빈은 아님
* bean factory
  * 스프링의 IoC를 담당하는 핵심 컨테이너
  * 보통 서브 클래스인 application context를 이용.
  * getBean()이 정의되어 있음.
* application context
  * bean factory를 확장한 IoC container
* 설정 정보
  * configuration
  * bean factory가 IoC를 적용하기 위해 사용하는 메타 정보
* container
  * IoC container

# 6. 싱글톤 레지스트리와 오브젝트 스코프

😎 DaoFactory의 userDao()를 두번 호출하면 그 두 obj는 동일한가?

당연히 다른다. 매번 새로 new 해서 반환하니까.

```java
DaoFactory daoFactory = new DaoFactory();
UserDao dao = daoFactory.userDao();
UserDao dao1 = daoFactory.userDao();
System.out.println("dao = " + dao);
System.out.println("dao1 = " + dao1);
```

하지만 ApplicationContext를 이용하면 같은  UserDao obj를 반환한다.

```java
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
UserDao dao2 = context.getBean("userDao", UserDao.class);
UserDao dao3 = context.getBean("userDao", UserDao.class);
System.out.println("dao2 = " + dao2);
System.out.println("dao3 = " + dao3);
```

## 6.1 싱글톤 레지스트리로서의 application context

application context의 역할

* 오브젝트 팩토리와 비슷하게 역할하는  IoC container
*  싱글톤을 저장하고 관리하는 single registry

### 서버 application 과 싱글톤

대부분의 스프링은 서버 환경에서 사용된다. 
초당 수백번의 요청을 처리하는 서버가 매 요청마다 로직을 담당하는 오브젝트를 새로 만들어서 사용하면 아무리 요즘 GC성능이 좋아도 부하가 걸리기 십상이다.

고로 application 안에 제한된 수, 대개 한 개의 obj만 만들어서 사용하는 것이 singleton pattern이다.  이렇게 만들어진 obj는 application 내에서 전역적으로 접근이 가능하다.

### singleton pattern 의 한계

자바에서 싱글톤 구현은 다음과 같다.

* class 밖에선 obj를 못 만들도록 생성자를 private박는다.
* 생성된 singleton obj를 저장할 static 필드를 정의한다.
* static factory method인 getInstance()를 만들고 이 메소드가 처음 호출됬을 때 오브젝트가 만들어지고,  만들어진 오브젝트는 위에서 만든 static field에 저장된다. 이후 호출에야 미리 만들어 놓은 obj를 넘겨준다.

```java
public class UserDao {
    private ConnectionMaker connectionMaker;
    private static UserDao INSTANCE;

    private UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }

    public static synchronized UserDao getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new UserDao(?);
        }
        return INSTANCE;
    }
    ...
}
```

🤔생성자가 private으로 바뀌니까 DaoFactory에서 UserDao를 생성해 ConnectionMaker를 넣어 주는 것도 이젠 안되겠는걸?

싱글톤의 문제는 이것뿐만 아니다.

* private 생성자를 갖고 있기 때문에 상속할 수 없다.
  * private이 아닌 생성자를 가지지 않은 이상 상속이 안된다. 
  * 고로 객체 지향의 장점인 상속과 다형성을 적용할 수 없다. 
* 테스트 하기 힘들다.
  * 싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에 쓰일 mock obj등으로 대체하기 어렵다. 
  * 초기화 과정에서 생성자 등을 통해 사용할 obj를 dynamic하게 주입하기 힘들기 때문에 필요한 obj는 직접 만들어 써야 한다. 
* 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
  * 서버에서 class loader를 어떻게 구성했는지에 따라 singleton class도 여러개의 obj가 만들어질 수 있다
  * 여러개의 JVM에 분산돼서 설치되는 경우에도 각각 독립적으로 생기기에 singleton pattern 이 깨진다.
* singleton 사용은 전역 상태를 만들 수 있기 때문에 부적절하다.
  * singleton 은 static method를 사용해 어디서든 사용될 수 있는데, 
    그러다 보면 global state로 사용되기 쉽다.
  * 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 객체지향에 위배된다.

### singleton registry

위와 같은 싱글톤의 단점들 떄문에 스프링은 직접 싱글톤을 생성하고 관리하고 공급한다. 이러한 기능을 singleton registry라 부른다.

singleton registry의 장점은

*  static method, private constructor를 써야하는 비정상적인 class가 아니라 평범한 class를 singleton으로 사용할 수 있게 해 준다.
  덕분에 singleton으로 사용되어야 하는 환경이 아니라면 public constructor로 자유롭게 obj를 만들 수 있다. 같은 이유로 mock obj로 대체하기도 쉽다.
* 생성자 parameter로 사용할 obj를 넣어줄 수도 있다.

이렇게 스프링이 빈을 singleton으로 만드는 것은 결국 obj생성 방법을 제어하는 IoC 컨테이너의 업무 중 하나이다. 

🤔그렇다면 singleton으로 만들어 지기 때문에 주의할 점은 무엇일까?

## 6.2 singleton 과 obj의 상태

singleton은 multi-thread환경이라면 여러 쓰레드가 동시에 접근해 쓸 수 있다. 
고로 상태 정보를 내부에 갖고 있지 않게(Stateless)만들어야 한다. 

🤔그렇다면 오가는 정보는 어떻게 다뤄야 할까? 

바로 메소드 parameter나 local variable, return value등을 이용하면 된다. 
이들은 매번 새로운 값을 저장할 독립적인 공간을 만들기 때문에 singleton이라고 threads가 변수의 값을 덮어쓸 일은 없다. 

😎당연히 읽기 전용 정보라면 싱글톤에서 인스턴스 변수로 사용해도 좋겠지?

## 6.3 스프링 빈의 스코프

scope = 빈이 생성되고 존재하고 적용되는 범위

scope 종류

* singleton scope
  * 기본 scope는 singleton scope이다. 이 친구는 컨테이너 내에 한 개의 obj만 만들어져 컨테이너가 존재하는한 계속 유지된다. 
* prototype scope
  * 컨테이너에 빈을 요청 할 때마다 매번 새로운 obj를 만들어 준다 .
* request scope
  * 웹을 통해 새로운 http 요청이 생길 때 마다 생성
* session scope

# 7. 의존 관계 주입 (DI)

## 7.1 IoC와 의존관계 주입

DaoFactory처럼 객체를 생성하고 관계를 맺어주는 기능을 일반화 한 것이 스프링의 IoC container다. 그런데 이 IoC가 워낙 자주 적용되는 개념이다 보니 스프링의 기능을 명확하게 설명하기엔 모호하다. 따라서 스프링이 제공하는 IoC방식을 "dependency injection" 이라고 명명한다.

DI는 obj reference를 외부에서 주입받고, 이를 통해 다이나믹하게 주변 obj와 의존관계를 만든다.

## 7.2 런타임 의존 관계 설정

### 의존 관계

![image](https://github.com/mtak0235/TIL/assets/48946398/00118e9a-80fb-4700-9aee-bf9e5aecb05c)

A가 B에 의존한다. == B가 변하면 A가 영향을 받는다. 

### UserDao의 의존관계

인터페이스를 통해 의존 관계를 제한해주면 그만큼 변경에서 자유로워진다. 
이렇게 느슨한 의존 관계를 갖는 경우 UserDao의 obj가 어떤 클래스의 obj를 쓸지 미리 알 수 없다. 

의존 관계 주입의 세가지 필수 조건

* 클래스 모델이나 코드에넌 런타임 시점의 의존 관계가 드러나지 않는다.
  * 인터페이스에만 의존하고 있어야 한다.
* 런타임 시점의 의존 관계는 컨테이너나 팩토리 같은 **제3의 존재**가 결정한다.
  * DaoFactory, ApplicationContext, Bean factory, IoC container
* 의존관계는 사용할 obj에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.

### UserDao의 의존 관계 주입

처음에..

```java
public UserDao() {
connectionMaker = new DConnectionMaker();
}
```

인터페이스를 끼워서 UserDao와 ConnectionMaker의 의존 관계를 느슨하게는 했지만 여전히 설계 시점에서 UserDao가 DConnectionMaker라는 구체적인 클래스를 알고 있었다. 즉, 모델링 때의 의존관계인 ConnectionMaker뿐 만 아니라 런타임 의존관계인 DConnectionMaker까지 알고 있다.  => 의존관계가 코드 속에 다 미리 결정되어 있다!

😎IoC방식으로 UserDao로부터 런타임 의존관계를 드러내는 코드를 덜어내 제 3의 존재(DaoFactory)에게 위임한다.

```java
public class UserDao {
private ConnectionMaker connectionMaker;
 
public UserDao(ConnectionMaker connectionMaker) {
 this.connectionMaker = connectionMaker;
}
…
}
```

=> 두 개의 오브젝트 간에 런타임 의존관계가 만들어졌다!

## 7.3 의존관계 검색과 주입

의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 IoC로 맡기지만, 
이를 가져올 때는 메소드나 생성자를 통한 주입 대신  **스스로 컨테이너에게 요청**하는 방법을 사용한다.

즉, 코드 안에 obj factory class나 spring api가 나타난다. 

```java
public UserDao() {
DaoFactory daoFactory = new DaoFactory();
this.connectionMaker = daoFactory.connectionMaker();
}

```

=> 외부로부터의 주입이 아니라 스스로 IoC 컨테이너인 DaoFactory에게 요청한다.

😎스프링의 애플리케이션 컨텍스트라면 미리 정해놓은  이름을 전달해서 그 이름에 해당하는 오브젝트를 찾게 된다. 

getBean()이 의존관계 검색에 사용된다. 

```java
public UserDao() {
AnnotationConfigApplicationContext context = 
 new AnnotationConfigApplicationContext(DaoFactory.class);
 this.connectionMaker = context.getBean("connectionMaker", ConnectionMaker.class);
}
```

| 의존관계 검색                                                | 의존 관계 주입                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 검색을 시작하려는 자신은 spring bean일 필요가 없다.<br />서버에는 main()같은 기동 메서드는 없지만<br />사용자의 요청 마다 비슷한 역할을 하는 servlet에서 spring container에 담긴 obj 를 사용하려면<br /> 한번은 의존 관계 검색으로 obj를 불러 와야 한다. | 검색을 하려는 자신과 검색 대상 모두 spring bean이어야 한다.<br />의존성 주입을 해주려면 UserDao에 대한 생성과 초기화 권한을 갖고 있어야 하기 때문이다. |



## 7.4 의존관계 주입의 응용

DI의 응용 사례를 생각해보자

###  기능 구현의 교환

개발 중 로컬 DB에서 작업 하다가 개발이 끝나서 배포할 때  운영 DB에 연결해야 한다. 

만약 DI를 안하면 Dao클래스들은 모두 new LocalDBConnectionMaker()에 의존하고 있을 것이다.  이러면 배포시 new ProductDBConnectionMaker()로 모두 바꿔줘야 하는데 실수할 가능성이 높아진다.

반면 DI를 적용했다면 모든 Dao는 생성 시점에 ConnectionMaker타입의 obj를 컨테이너로부터 받는다. 우리는 @Configuration이 붙은 DaoFactory 클래스에 다음과 같이 수정만 해주면 된다.

```java
@Bean
public ConnectionMaker connectionMaker() {
	 return new LocalDBConnectionMaker();
//     return new ProductionDBConnectionMaker(); 배포시 이것만 코드 바꾸면 된다.
}
```

### 부가 기능 추가

DI가 적용되지 않았다면 DB connection 을 카운팅 하고 싶을 때 모든 makeConenction() 호출에 카운트를 증가 시키는 코드를 넣어야 한다. 분석 끝나면 다 제거해야하고.. 또문제는 DB연결 카운팅을 Dao의 관심 사항이 아닌데 코드를 수정당해야 한다는 것이다.

DI 컨테이너라면 아주 쉽게 Dao와 DB connetion을 만드는 obj사이에 연결 횟수를 카운팅하는 obj를 하나 더 추가하면 된다. 

```java
package com.example.tobby.user.dao;

import java.sql.Connection;
import java.sql.SQLException;

public class CountingConnectionMaker implements ConnectionMaker {
    int counter = 0;
    private final ConnectionMaker realConnectionMaker;

    public CountingConnectionMaker(ConnectionMaker realConnectionMaker) {
        this.realConnectionMaker = realConnectionMaker;
    }

    @Override
    public Connection makeConnection() throws ClassNotFoundException, SQLException {
        this.counter++;
        return realConnectionMaker.makeConnection();
    }

    public int getCounter() {
        return counter;
    }
}

```

```java
package com.example.tobby.user.dao;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CountingDaoFactory {
    @Bean
    public UserDao userDao() {
        UserDao userDao = new UserDao(connectionMaker());
        return userDao;
    }

    @Bean
    public ConnectionMaker connectionMaker() {
        return new CountingConnectionMaker(realConnectionMaker());
    }

    @Bean
    public ConnectionMaker realConnectionMaker() {
        return new DConnectionMaker();
    }
}
```

```java
package com.example.tobby.user.dao;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
class CountingConnectionMakerTest {

    @Test
    void makeConnection() {
        AnnotationConfigApplicationContext context =
                new AnnotationConfigApplicationContext(CountingDaoFactory.class);
        UserDao dao = context.getBean("userDao", UserDao.class);
        CountingConnectionMaker ccm = context.getBean("connectionMaker", CountingConnectionMaker.class);
        System.out.println("ccm.getCounter() = " + ccm.getCounter());
    }
}
```

😎어쩃든 분석이 끝나면 설정 클래스를 다시  CountingDaoFactory에서 DaoFactory로 바꾸거나, connectionMaker()만 수정하면 된다!

## 7.5 메소드를 이용한 의존 관계 주입

지금까지는 UserDao의 DI를 생성자를 통해서만 했다.
생성자에 parameter를 만들어 두고 DI container가 의존할 obj reference를 넘겨주도록 만들었다. 

하지만 DI하는데 생성자를 쓸 필요 없이 일반 메소드를 사용할 수도 있다. 

크게 2가지 방법이 있다.

1. 수정자 메소드를 이용한 주입
   * setter()
   * 한번에 한개의 parameter 만 가능하다.🥺
   * 젤 많이 쓴다.
2. 일반 메소드를 이용한 주입
   * 한번에 여러개의 parameter를 받을 수 있게 만들 수 있다.

😎UserDao도 수정자 메소드를 이용해 DI하도로 만들어 보자

```java
package com.example.tobby.user.dao;

import com.example.tobby.user.domain.User;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class UserDao {
    private ConnectionMaker connectionMaker;

//    public UserDao(ConnectionMaker connectionMaker) {
//        this.connectionMaker = connectionMaker;
//    }

    public void setConnectionMaker(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }

    public void add(User user) throws ClassNotFoundException, SQLException, SQLException {
        Connection c = connectionMaker.makeConnection();

        PreparedStatement ps = c.prepareStatement(
                "insert into users (id, name, password) values (?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());
        ps.executeUpdate();
        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();

        PreparedStatement ps = c.prepareStatement(
                "select * from users where id = ?"
        );
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
        rs.close();
        ps.close();
        c.close();
        return user;
    }
}

```

```java
package com.example.tobby.user.dao;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class DaoFactory {
    @Bean
    public UserDao userDao() {
        UserDao userDao = new UserDao();
        userDao.setConnectionMaker(connectionMaker());
        return userDao;
    }

    @Bean
    public ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    }
}


```

# 8. XML을 이용한 설정

🤔DaoFactory는 DI의 동작 원리를 잘 이용해 독립적인 obj factory 클래스로 시작했지만, DI container를 도입하면서 @Configuration을 추가해  DI 작업에 참고하는 일종의 참고 정보로 이용되고 있어.
근데 DaoFactory를 보면 비슷한 구조가 반복되고 DI 구성이 바뀔 때 마다 자바 코드를 수정하고 클래스를 다기 컴파일 하는 것도 귀찮다. 

😎spring은 자바 클래스를 이용하는 것 외에도 다양한 방법으로 DI의 설정 정보를 만들 수 있는데 대표적으로 XML 이 있다.

## 8.1 XML 설정

XML  파일은 beans를 @Configuration대용으로 사용한다.
즉, <beans> 안에 여러개의 <bean>을 정의할 수 있다. 

@Bean 메소드로 얻을 수 있는 빈의 정보 3가지!

* 빈의 이름
* 빈의 클래스
* 빈의 의존 오브젝트

### connectionMaker()전환

|              | 자바코드 설정 정보     | XML 설정 정보             |
| ------------ | ---------------------- | ------------------------- |
| 빈 설정 파일 | @Configuration         | <beans>                   |
| 빈의 이름    | @Bean methodName()     | <bean id="methodName"     |
| 빈의 클래스  | return new BeanClass() | class="a.b.c...BeanClass" |

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="connectionMaker" class="com.example.tobby.user.dao.DConnectionMaker"/>
    
</beans>
```

### userDao() 전환

![image](https://github.com/mtak0235/TIL/assets/48946398/7f25797c-7749-4dd6-89bc-d52a2ddce27e)

xml에서는 <property>로 의존 오브젝트와의 관계를 정의한다.
name : 수정자의 메소드를 알 수 있다. 
ref : 수정자 메소드를 통해 주입해줄 오브젝트의 빈 이름.(id부분)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="connectionMaker" class="com.example.tobby.user.dao.DConnectionMaker"/>
    <bean id="userDao" class="com.example.tobby.user.dao.UserDao">
        <property name="connectionMaker" ref="connectionMaker"/>
    </bean>
</beans>
```

```java
@Test
void UserDaoXMLTest() throws SQLException, ClassNotFoundException {
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext("test.xml");
    UserDao dao = applicationContext.getBean("userDao", UserDao.class);
    User user = new User();
    user.setId("mta11");
    user.setName("탁민경");
    user.setPassword("1004");
    dao.add(user);
    System.out.println("succeed " + user.getId());

    User user1 = dao.get(user.getId());
    System.out.println(user1.getId());
    System.out.println(user1.getName());
    System.out.println(user1.getPassword());
    System.out.println("succeed" + user1.getId());
}
```

😎xml에선 같은 인터페이스를 구현한 의존 오브젝트를 여러개 정의해 두고 그 중에서 원하는걸 골라 DI할 수도 있다!

```xml
<beans>
<bean id="localDBConnectionMaker" class="...LocalDBConnectionMaker" />
<bean id="testDBConnectionMaker" class="...TestDBConnectionMaker" />
 <bean id="productionDBConnectionMaker" class="...ProductionDBConnectionMaker" />
<bean id="userDao" class="springbook.user.dao.UserDao">
 <property name="connectionMaker" ref="localDBConnectionMaker" />
</bean>
</beans>
```

## 8.2  xml을 이용하는 application context

xml의 빈 의존 관계 정보를 이용하려면,(getBean()) GenericXmlApplicationContext를 사용한다. 

```java
    @Test
    void UserDaoXMLTest() throws SQLException, ClassNotFoundException {
//      ApplicationContext applicationContext = new ClassPathXmlApplicationContext("test.xml");

        GenericXmlApplicationContext applicationContext = new GenericXmlApplicationContext("test.xml");
        UserDao dao = applicationContext.getBean("userDao", UserDao.class);
        User user = new User();
        user.setId("mta12");
        user.setName("탁민경");
        user.setPassword("1004");
        dao.add(user);
        System.out.println("succeed " + user.getId());

        User user1 = dao.get(user.getId());
        System.out.println(user1.getId());
        System.out.println(user1.getName());
        System.out.println(user1.getPassword());
        System.out.println("succeed" + user1.getId());
    }
```

xml설정 파일의 이름은 일반적으로 applicationContext.xml이라 짓는다.
위치는 일반적으로 /resources 에 둔다.

만약 xml이 user/dao/test.xml에 있으면 다음과 같이 가져오면 된다.

```java
        GenericXmlApplicationContext applicationContext = new GenericXmlApplicationContext("com/example/tobby/user/dao/test.xml");
```

경로가 너무 길다. 이 때는 ClassPathXmlApplication을 사용할 수 있다.

```java
new ClassPathXmlApplicationContext("daoContext.xml", UserDao.class);
```

🤷‍♂️난 안되는데? /resources 안에 있을때만 인식하는데?

## 8.3 DataSource 인터페이스로 변환

ConnectionMaker는   DB connection을 만드는 기능 하나만 가진 매우 간단한 인터페이스다. 사실 자바에는 이런 용도의 인터페이스가 이미 있다. 그거슨 바로 DataSource인터페이스.

하지만 이 놈은 DB connection을 가져오는 것 외에도 여러 기능이 있어서 인터페이스를 구현하기엔 좀 부담스럽다.
걱정 말자. 이미 DB연결 뿐 아니라 pooling까지 갖춘 DataSource구현체들이 많다 . 

ConnectionMaker의 makeConnection()이나 DataSource의 getConnection()은 같은 놈이다. 

😎이제 ConnectionMaker는 필요 없다. DataSource로 모조리 바꿔버리자.

```java
package com.example.tobby.user.dao;

import com.example.tobby.user.domain.User;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class UserDao {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public void add(User user) throws ClassNotFoundException, SQLException, SQLException {
        Connection c = dataSource.getConnection();

        PreparedStatement ps = c.prepareStatement(
                "insert into users (id, name, password) values (?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());
        ps.executeUpdate();
        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = dataSource.getConnection();

        PreparedStatement ps = c.prepareStatement(
                "select * from users where id = ?"
        );
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
        rs.close();
        ps.close();
        c.close();
        return user;
    }
}

```

이제 DataSource 구현 클래스가 필요하다. DConnectionMaker처럼 따로 만들지는 말고 스피링이 제공하는  SimpleDriverDataSource를 사용하자. 

### 자바 코드 설정 방식

```java
package com.example.tobby.user.dao;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.SimpleDriverDataSource;

import javax.sql.DataSource;

@Configuration
public class DaoFactory {
    @Bean
    public DataSource dataSource(){
        SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
        dataSource.setDriverClass(com.mysql.cj.jdbc.Driver.class);
        dataSource.setUrl("jdbc:mysql://localhost/tobby");
        dataSource.setUsername("tobaby");
        dataSource.setPassword("0000");
        return dataSource;
    }
    @Bean
    public UserDao userDao() {
        UserDao userDao = new UserDao();
        userDao.setDataSource(dataSource());
        return userDao;
    }

    @Bean
    public ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    }
}

```

###  XML설정 방식

```xml
    <bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource"/>
```

xml에선 어떻게 dataSource() 처럼 DB연결 정보를 넣도록 설정을 만들 수 있을까?

## 8.4 프로퍼티 값의 주입

### 값 주입

텍스트나 단순 오브젝트 등을 수정자 메소드에 넣어 주는 것을 "값을 주입한다"라고 한다. 

스프링 빈으로 등록될 클래스에 setter() 가 있으면 여전히 <property>를 사용해 주입할 정보를 지정할 수 있다는 점은 같다.하지만 다른 bean obj의 ref가 아니라 단순 value 를 주입해 주는 것이라 ref attribute 대신에 value attribute를 사용한다. 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="connectionMaker" class="com.example.tobby.user.dao.DConnectionMaker"/>
    <bean id="userDao" class="com.example.tobby.user.dao.UserDao">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
        <property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost/tobby"/>
        <property name="username" value="tobaby"/>
        <property name="password" value="0000"/>
    </bean>
</beans>
```

### value 값의 자동 변환

xml 파일에서 스프링은 value에서 지정한 텍스트 값을 적절한 자바 타입(Integer, Double, Boolean, Class, URL, File, Charset etc)으로 변환해준다. 또 값이 여러개라면 List, Set, Properties 나 배열 타입으로도 값 주입이 가능하다.

```java
Class driverClass = Class.forName("com.mysql.jdbc.Driver");
dataSource.setDriverClass(driverClass);
```

